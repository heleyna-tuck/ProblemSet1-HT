---
title: "STATS506_ProbSet1"
author: "Heleyna Tucker"
format: html
editor: visual
---

# Problem 1

### Part A: Import the data into a 'data.frame' in R. I have given the appropriate column name to the data frame as well:

```{r}
col_names <- c('class','Alcohol', 'Malic acid', 'Ash', 'Alcalinity of ash', 'Magnesium', 'Total phenols', 'Flavanoids', 'Nonflavanoid phenols', 'Proanthocyanins', 'Color intensity', 'Hue', 'OD280/OD315 of diluted wines', 'Proline')
wine_data <- read.table(file="/Users/19892/OneDrive/Documents/STATS506/ProblemSets/ProblemSet1-HT/wine.data", sep=",", header=TRUE, col.names = col_names)

wine_data
```

### Part B: The data contains three different classes of wine (1, 2, 3) as seen in the above data frame.

### Part C: Next, I will use the data to answer the following questions:

1.  What class does the highest alcohol content belong to?

    We will do this using the 'which.max()' function in the Alcohol column from 'wine_data'.

    ```{r}
    max_alcohol <- wine_data[which.max(wine_data$Alcohol),]
    max_alcohol
    ```

Here, we find that the highest alcohol content belongs to class 1, being 14.83 ABV (alcohol by volume).

2.  The wine with the lowest alcohol content belongs to which class?

````         
For this, we will use a similar function, except with the 'which.min()' function in the Alcohol column from 'wine_data'.

```{r}
min_alcohol <- wine_data[which.min(wine_data$Alcohol),]
min_alcohol
```
````

Here, we find that the lowest alcohol content belongs to class 2, being 11.03 ABV.

3.  German beers have, on average 114 mg/l of magnesium. How many of these wines have higher levels of magnesium than that? We will assume that the magnesium reported in the data is in the same units.

````         
Below we will use the length() function, along with the which() function and the given inequality to find how many wines have higher than 114 mg/l of magnesium.

```{r}
length(which(wine_data$Magnesium > 114))
```
````

Found above, there are 25 wines that satisfy the inequality.

4.  Within each class, how many wines have higher levels of magnesium than average German beer?

    I will use a similar technique as before, but adding the condition of what class each condition has.

    ```{r}
    length(which(wine_data$class == 1 & wine_data$Magnesium > 114))

    length(which(wine_data$class == 2 & wine_data$Magnesium > 114))

    length(which(wine_data$class == 3 & wine_data$Magnesium > 114))
    ```

Above we can see that the code tells us that 14 wines in class 1, 6 wines in class 2, and 5 wines in class 3 have higher levels of magnesium than average German beer.

### Part D: I will now create a table identifying the average value of each variable. One row will be provided with the overall average and one row per class with the class averages.

I will use the colMeans() function to calculate the overall means and individual class (1, 2, 3) means and put the results into a data frame named averages.

```{r}
overall_means <- colMeans(wine_data[,2:14])
class1_means <- colMeans(wine_data[wine_data$class == 1,])
class2_means <- colMeans(wine_data[wine_data$class == 2,])
class3_means <- colMeans(wine_data[wine_data$class == 3,])

averages <- data.frame('Overall mean' = overall_means, 
                        'Class1 mean' = class1_means[2:14], 
                        'Class2 mean' = class2_means[2:14], 
                        'Class3 mean' = class3_means[2:14])

averages
```

Above, we can see the overall means and individual class means. One observation that can be made is that class 1 and class 3 wines have a higher alcohol content than the overall average wine.

### Part E: Below, I will carry out some t-tests to examine whether the level of Ash differs across the three classes.

```{r}
t.test(wine_data$Ash[wine_data$class = 1], wine_data$Ash[wine_data$class = 2], wine_data$Ash[wine_data$class = 3])
```

*I'm not sure how to do this lol*

# Problem 2

### Part A: Below, I will write a function "isPerfectPower" to identify whether a given integer is a perfect power for a given power.

In the 'isPerfectPower()' function, I take in n and power. I use modular arithmetic: n\^(1/power)mod1

If the remainder is 0, this tells us that the power-root of n is an integer. In other words, n would then be a "perfect power" and there exists an integer *r* (root) and *p* (the power) such that *r\^p = n*. I also output the root itself.

I also included if n\^(1/power)mod1 is 1 then the root is also perfect to account for rounding errors.

-   Not sure how to get these to equal each other below. I think I got this? ask...

```{r}
isPerfectPower <- function(n, power) {
  if(all.equal((n^(1/power) %% 1), 0) == TRUE){
    Perfect = TRUE
  }
  else if(all.equal((n^(1/power) %% 1), 1) == TRUE){
    Perfect = TRUE
  }
  else{
    Perfect = FALSE
  }
  output <- list(isPerfect = Perfect, 
                 root = n^(1/power))
  return(output)
}
```

Check if the function is working below:

```{r}
isPerfectPower(125, power = 2)
isPerfectPower(125, power = 3)

```

Above we can see an example of the function being used. This says that given the numbers, 27 is a perfect power, where 3\^3 = 27.

### Part B: I will demonstrate how the function in Part A works be writing another function "findRootPower()" that calls my first function, using a loop to identify both the root and power. My function will identify the *lowest* power for which the input is perfect.

Below, I have the findRootPower() function check roots 2-200 on any given number, utilizing the isPerfectPower() function that was coded in part (a) if the isPerfectPower function returns TRUE, then the function returns the perfect power equation for the given number. If the loop goes through all 2-200 power options, then the function returns "Input is not a perfect power."

```{r}
findRootPower <- function(num) {
  for (i in 2:200){
    list <- isPerfectPower(num, i)
    if (list$isPerfect == TRUE) {
      return(cat(num, " = ",list$root, "^", i, sep = ''))
    }
      
  }
  return("Input is not a perfect power (for powers 2-200).")
    
}
```

```{r}
findRootPower(94143178827)
```

Here are some test values and what findRootPower() outputs (the last test number is shown above):

-   27 = 3\^3

-   13060694016 = 6\^13

-   7776 = 6\^5

-   170859375 = 15\^7

-   58247422 : "Input is not a perfect power (for powers 2-200)."

-   94143178827 = 3\^23

# Problem 3

This problem will lean into ChatGPT and other LLMs (Large Language Models):

### Part A: 

I will input the given prompt in ChatGPT:

Produce two R functions: The first should take in a vector of suits and a vector of ranks representing a 5-card hand, and return the name of the hand (in 5 card stud poker). The second should simulate dealing a round of cards in a game of poker (5 card stud). The user should be able to specify the number of players. Show the user all the hands, and use the first function to display the name of each of the hands.

And copy it's output:

```{r}
# Function to determine the name of a poker hand
determine_poker_hand <- function(suits, ranks) {
  if (length(unique(suits)) == 1) {
    # Check for a flush
    if (length(unique(ranks)) == 5 && max(ranks) - min(ranks) == 4) {
      if (max(ranks) == 14) {
        return("Royal Flush")
      } else {
        return("Straight Flush")
      }
    } else {
      return("Flush")
    }
  } else if (length(unique(ranks)) == 2) {
    # Check for four of a kind or full house
    counts <- table(ranks)
    if (max(counts) == 4) {
      return("Four of a Kind")
    } else {
      return("Full House")
    }
  } else if (length(unique(ranks)) == 3) {
    # Check for three of a kind or two pairs
    counts <- table(ranks)
    if (max(counts) == 3) {
      return("Three of a Kind")
    } else {
      return("Two Pairs")
    }
  } else if (length(unique(ranks)) == 4) {
    # Check for one pair
    return("One Pair")
  } else {
    # Check for straight or high card
    if (length(unique(ranks)) == 5 && max(ranks) - min(ranks) == 4) {
      return("Straight")
    } else {
      return("High Card")
    }
  }
}

# Function to simulate a round of 5-card stud poker
simulate_poker_round <- function(num_players) {
  # Create a deck of cards
  suits <- rep(c("Hearts", "Diamonds", "Clubs", "Spades"), each = 13)
  ranks <- rep(2:10, 4)
  #Added rank_suits to account for 4 sets of Jack, Queen, King, and Ace also being in the deck
  ranks_suit <- rep(c("Jack", "Queen", "King", "Ace"), 4)
  ranks <- c(ranks, ranks_suit)
  print(ranks)
  print(length(ranks))
  
  # Shuffle the deck
  deck <- sample(1:52)
  print(deck[1:5])
  # Deal cards to each player
  player_hands <- vector("list", length = num_players)
  for (i in 1:num_players) {
    player_hands[[i]] <- deck[(((i - 1) * 5) + 1):(i * 5)]
  }
  
  # Determine and display the name of each player's hand
  for (i in 1:num_players) {
    hand <- player_hands[[i]]
    hand_suits <- suits[hand]
    hand_ranks <- ranks[hand %% 13]
    cat("Player", i, "Hand:", hand_suits, hand_ranks, "\n")
    cat("Hand Name:", determine_poker_hand(hand_suits, hand_ranks), "\n\n")
  }
}

```

Here are some input examples:

```{r}
# Usage example:
simulate_poker_round(4)  # Simulate a round of poker with 4 players


```
Note: I can't figure out how to get the ranks/suits to allign right, the Jack,Queen, King, and Ace are not-numeric so idk how to make it work. Ask: does it have to work or just run??




